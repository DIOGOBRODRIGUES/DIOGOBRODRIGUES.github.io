<!doctype html>
<html lang="pt-BR">

<head>
  <meta charset="utf-8">
  <title>Aula 6: Sensores e GeolocalizaÃ§Ã£o</title>

  <meta name="description" content="OperaÃ§Ã£o de sensores mÃ³veis, GPS, mapas e sensores biomÃ©tricos para alta performance">
  <meta name="author" content="Prof. Dr. Diogo Francisco Borba Rodrigues">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <link rel="stylesheet" href="../../../../reveal.js-master/dist/reset.css">
  <link rel="stylesheet" href="../../../../reveal.js-master/dist/reveal.css">
  <link rel="stylesheet" href="../../../../reveal.js-master/dist/theme/dracula.css" id="theme">

  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="../../../../reveal.js-master/plugin/highlight/monokai.css">

</head>

<body>
 
  <div class="reveal">
    <div class="slides">
      <!-- Slide 1 - TÃ­tulo da Aula -->
      <section>
        <p>ğŸ›ï¸ Centro UniversitÃ¡rio MaurÃ­cio de Nassau</p>
        <h3>Aula 6: Sensores e GeolocalizaÃ§Ã£o</h3>
        <p><strong>CodificaÃ§Ã£o de Alta Performance Mobile</strong></p>
        <p>Prof. Dr. Diogo Francisco Borba Rodrigues</p>
        <a href="https://www.linkedin.com/in/diogo-francisco-borba-rodrigues-3a1b5179/" target="_blank">
          <i class="fab fa-linkedin"></i>
        </a>
        <a href="https://github.com/DIOGOBRODRIGUES" target="_blank">
          <i class="fab fa-github"></i>
        </a>
        <a href="https://www.instagram.com/diogofbranco" target="_blank">
          <i class="fab fa-instagram"></i>
        </a>
      </section>

      <!-- Slide 2 - Objetivos da Aula -->
      <section>
        <h2>ğŸ¯ Objetivos da Aula</h2>
        <ul>
          <li>ğŸ“ Implementar geolocalizaÃ§Ã£o precisa com GPS</li>
          <li>ğŸ§­ Usar sensores de movimento (acelerÃ´metro, giroscÃ³pio)</li>
          <li>ğŸ—ºï¸ Integrar APIs de mapas (Google Maps, Apple Maps)</li>
          <li>ğŸ›£ï¸ Criar sistema de rotas e navegaÃ§Ã£o</li>
          <li>ğŸ‘† Implementar sensores biomÃ©tricos</li>
          <li>âš¡ Otimizar consumo de bateria dos sensores</li>
        </ul>
      </section>

      <!-- Slide 3 - Sensores MÃ³veis Overview -->
      <section>
        <h2>ğŸ“± Sensores em Dispositivos MÃ³veis</h2>
        <section>
          <h3>ğŸ”¬ Tipos de Sensores</h3>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
            <div>
              <h4>ğŸŒ LocalizaÃ§Ã£o</h4>
              <ul style="font-size: 0.8em;">
                <li>ğŸ“ <strong>GPS:</strong> Global Positioning</li>
                <li>ğŸ“¡ <strong>A-GPS:</strong> Assisted GPS</li>
                <li>ğŸ—¼ <strong>Cell Tower:</strong> Torres celulares</li>
                <li>ğŸ“¶ <strong>WiFi:</strong> TriangulaÃ§Ã£o WiFi</li>
              </ul>
            </div>
            <div>
              <h4>ğŸƒâ€â™‚ï¸ Movimento</h4>
              <ul style="font-size: 0.8em;">
                <li>âš¡ <strong>AcelerÃ´metro:</strong> AceleraÃ§Ã£o</li>
                <li>ğŸŒ€ <strong>GiroscÃ³pio:</strong> RotaÃ§Ã£o</li>
                <li>ğŸ§­ <strong>MagnetÃ´metro:</strong> Campo magnÃ©tico</li>
                <li>ğŸ“ <strong>BarÃ´metro:</strong> PressÃ£o/altitude</li>
              </ul>
            </div>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 2rem;">
            <div>
              <h4>ğŸ‘ï¸ BiomÃ©tricos</h4>
              <ul style="font-size: 0.8em;">
                <li>ğŸ‘† <strong>Touch ID:</strong> Digital</li>
                <li>ğŸ‘ï¸ <strong>Face ID:</strong> Reconhecimento facial</li>
                <li>ğŸ—£ï¸ <strong>Voice:</strong> Reconhecimento de voz</li>
              </ul>
            </div>
            <div>
              <h4>ğŸŒ¡ï¸ Ambiente</h4>
              <ul style="font-size: 0.8em;">
                <li>ğŸ’¡ <strong>Luz:</strong> Sensor de luminosidade</li>
                <li>ğŸ”Š <strong>Ãudio:</strong> Microfone</li>
                <li>ğŸ“· <strong>CÃ¢mera:</strong> Visual/AR</li>
              </ul>
            </div>
          </div>
        </section>
        <section>
          <h3>âš¡ Desafios de Performance</h3>
          <ul>
            <li>ğŸ”‹ <strong>Bateria:</strong> GPS consome ~20-50% mais energia</li>
            <li>ğŸ“Š <strong>PrecisÃ£o vs Consumo:</strong> Mais precisÃ£o = mais energia</li>
            <li>â±ï¸ <strong>LatÃªncia:</strong> Tempo para primeiro fix GPS</li>
            <li>ğŸ¢ <strong>Indoor vs Outdoor:</strong> LimitaÃ§Ãµes de sinal</li>
            <li>ğŸ“± <strong>Background:</strong> RestriÃ§Ãµes do sistema</li>
          </ul>
        </section>
      </section>

      <!-- Slide 4 - GeolocalizaÃ§Ã£o com Expo -->
      <section>
        <h2>ğŸ“ GeolocalizaÃ§Ã£o com Expo Location</h2>
        <section>
          <h3>ğŸš€ Setup e PermissÃµes</h3>
          <pre><code data-trim class="bash">
# Instalar expo-location
expo install expo-location

# app.json - Configurar permissÃµes
{
  "expo": {
    "name": "GeoApp",
    "plugins": [
      [
        "expo-location",
        {
          "locationAlwaysAndWhenInUsePermission": "Allow $(PRODUCT_NAME) to use your location.",
          "locationAlwaysPermission": "Allow $(PRODUCT_NAME) to use your location.",
          "locationWhenInUsePermission": "Allow $(PRODUCT_NAME) to use your location.",
          "isIosBackgroundLocationEnabled": true,
          "isAndroidBackgroundLocationEnabled": true
        }
      ]
    ]
  }
}
          </code></pre>
        </section>
        <section>
          <h3>ğŸ“ ServiÃ§o de LocalizaÃ§Ã£o</h3>
          <pre><code data-trim class="javascript">
// services/LocationService.js
import * as Location from 'expo-location';
import * as TaskManager from 'expo-task-manager';

const LOCATION_TRACKING = 'location-tracking';

class LocationService {
  constructor() {
    this.currentLocation = null;
    this.isTracking = false;
    this.subscribers = [];
  }

  async requestPermissions() {
    try {
      // Verificar se serviÃ§os estÃ£o habilitados
      const servicesEnabled = await Location.hasServicesEnabledAsync();
      if (!servicesEnabled) {
        throw new Error('Location services are disabled');
      }

      // Solicitar permissÃµes
      const { status: foregroundStatus } = await Location.requestForegroundPermissionsAsync();
      if (foregroundStatus !== 'granted') {
        throw new Error('Foreground location permission denied');
      }

      // Para background location
      const { status: backgroundStatus } = await Location.requestBackgroundPermissionsAsync();
      if (backgroundStatus !== 'granted') {
        console.warn('Background location permission denied');
      }

      return {
        foreground: foregroundStatus === 'granted',
        background: backgroundStatus === 'granted'
      };
    } catch (error) {
      console.error('Permission request failed:', error);
      throw error;
    }
  }

  async getCurrentLocation(options = {}) {
    const {
      accuracy = Location.Accuracy.Balanced,
      maximumAge = 10000, // 10 seconds
      timeout = 15000,    // 15 seconds
    } = options;

    try {
      const location = await Location.getCurrentPositionAsync({
        accuracy,
        maximumAge,
        timeout,
      });

      this.currentLocation = {
        latitude: location.coords.latitude,
        longitude: location.coords.longitude,
        altitude: location.coords.altitude,
        accuracy: location.coords.accuracy,
        timestamp: location.timestamp,
        speed: location.coords.speed,
        heading: location.coords.heading,
      };

      this.notifySubscribers(this.currentLocation);
      return this.currentLocation;
    } catch (error) {
      console.error('Get current location failed:', error);
      throw error;
    }
  }

  async startTracking(options = {}) {
    const {
      accuracy = Location.Accuracy.Balanced,
      timeInterval = 5000,        // 5 seconds
      distanceInterval = 10,      // 10 meters
      showsBackgroundLocationIndicator = true
    } = options;

    try {
      await Location.startLocationUpdatesAsync(LOCATION_TRACKING, {
        accuracy,
        timeInterval,
        distanceInterval,
        showsBackgroundLocationIndicator,
        foregroundService: {
          notificationTitle: 'Rastreando localizaÃ§Ã£o',
          notificationBody: 'O app estÃ¡ monitorando sua localizaÃ§Ã£o',
          notificationColor: '#007AFF'
        }
      });

      this.isTracking = true;
      console.log('Location tracking started');
    } catch (error) {
      console.error('Start tracking failed:', error);
      throw error;
    }
  }

  async stopTracking() {
    try {
      await Location.stopLocationUpdatesAsync(LOCATION_TRACKING);
      this.isTracking = false;
      console.log('Location tracking stopped');
    } catch (error) {
      console.error('Stop tracking failed:', error);
    }
  }

  subscribe(callback) {
    this.subscribers.push(callback);
    return () => {
      this.subscribers = this.subscribers.filter(sub => sub !== callback);
    };
  }

  notifySubscribers(location) {
    this.subscribers.forEach(callback => callback(location));
  }
}

// Definir task para background tracking
TaskManager.defineTask(LOCATION_TRACKING, ({ data, error }) => {
  if (error) {
    console.error('Background location error:', error);
    return;
  }
  if (data) {
    const { locations } = data;
    console.log('Background locations:', locations);
    // Processar localizaÃ§Ãµes em background
  }
});

export default new LocationService();
          </code></pre>
        </section>
      </section>

      <!-- Slide 5 - Sensores de Movimento -->
      <section>
        <h2>ğŸƒâ€â™‚ï¸ Sensores de Movimento</h2>
        <section>
          <h3>âš¡ AcelerÃ´metro e GiroscÃ³pio</h3>
          <pre><code data-trim class="javascript">
// expo install expo-sensors
import { Accelerometer, Gyroscope, Magnetometer } from 'expo-sensors';

class MotionSensorService {
  constructor() {
    this.accelerometerData = null;
    this.gyroscopeData = null;
    this.magnetometerData = null;
    this.isMotionTracking = false;
  }

  async startMotionTracking() {
    try {
      // Verificar disponibilidade dos sensores
      const [accelAvailable, gyroAvailable, magAvailable] = await Promise.all([
        Accelerometer.isAvailableAsync(),
        Gyroscope.isAvailableAsync(),
        Magnetometer.isAvailableAsync()
      ]);

      console.log('Sensors availability:', {
        accelerometer: accelAvailable,
        gyroscope: gyroAvailable,
        magnetometer: magAvailable
      });

      // Configurar frequÃªncia de atualizaÃ§Ã£o (em ms)
      Accelerometer.setUpdateInterval(100); // 10 Hz
      Gyroscope.setUpdateInterval(100);     // 10 Hz
      Magnetometer.setUpdateInterval(1000); // 1 Hz

      // Iniciar listeners
      this.accelerometerSubscription = Accelerometer.addListener(data => {
        this.accelerometerData = {
          x: data.x,
          y: data.y,
          z: data.z,
          timestamp: Date.now()
        };
        this.processAccelerometerData(data);
      });

      this.gyroscopeSubscription = Gyroscope.addListener(data => {
        this.gyroscopeData = {
          x: data.x, // rotation around x-axis
          y: data.y, // rotation around y-axis
          z: data.z, // rotation around z-axis
          timestamp: Date.now()
        };
        this.processGyroscopeData(data);
      });

      this.magnetometerSubscription = Magnetometer.addListener(data => {
        this.magnetometerData = {
          x: data.x,
          y: data.y,
          z: data.z,
          timestamp: Date.now()
        };
        this.processMagnetometerData(data);
      });

      this.isMotionTracking = true;
      console.log('Motion tracking started');
    } catch (error) {
      console.error('Motion tracking start failed:', error);
    }
  }

  processAccelerometerData(data) {
    // Detectar movimento (shake, tilt, etc)
    const acceleration = Math.sqrt(data.x * data.x + data.y * data.y + data.z * data.z);
    
    // Detectar shake gesture
    if (acceleration > 2.5) {
      this.onShakeDetected();
    }

    // Detectar orientaÃ§Ã£o do dispositivo
    const orientation = this.getDeviceOrientation(data);
    this.onOrientationChanged(orientation);
  }

  processGyroscopeData(data) {
    // Detectar rotaÃ§Ã£o rÃ¡pida
    const rotationMagnitude = Math.sqrt(data.x * data.x + data.y * data.y + data.z * data.z);
    
    if (rotationMagnitude > 3.0) {
      this.onFastRotationDetected();
    }
  }

  processMagnetometerData(data) {
    // Calcular direÃ§Ã£o da bÃºssola
    const heading = Math.atan2(data.y, data.x) * (180 / Math.PI);
    const normalizedHeading = (heading + 360) % 360;
    
    this.onCompassHeadingChanged(normalizedHeading);
  }

  getDeviceOrientation(accelerometerData) {
    const { x, y, z } = accelerometerData;
    
    if (Math.abs(x) > Math.abs(y)) {
      return x > 0 ? 'left' : 'right';
    } else {
      return y > 0 ? 'down' : 'up';
    }
  }

  // Event handlers (implementar conforme necessÃ¡rio)
  onShakeDetected() {
    console.log('Shake gesture detected!');
    // Implementar aÃ§Ã£o do shake
  }

  onOrientationChanged(orientation) {
    console.log('Device orientation changed to:', orientation);
  }

  onFastRotationDetected() {
    console.log('Fast rotation detected!');
  }

  onCompassHeadingChanged(heading) {
    console.log('Compass heading:', heading.toFixed(1), 'Â°');
  }

  stopMotionTracking() {
    if (this.accelerometerSubscription) {
      this.accelerometerSubscription.remove();
    }
    if (this.gyroscopeSubscription) {
      this.gyroscopeSubscription.remove();
    }
    if (this.magnetometerSubscription) {
      this.magnetometerSubscription.remove();
    }
    
    this.isMotionTracking = false;
    console.log('Motion tracking stopped');
  }
}

export default new MotionSensorService();
          </code></pre>
        </section>
      </section>

      <!-- Slide 6 - IntegraÃ§Ã£o com Mapas -->
      <section>
        <h2>ğŸ—ºï¸ IntegraÃ§Ã£o com APIs de Mapas</h2>
        <section>
          <h3>ğŸŒ React Native Maps</h3>
          <pre><code data-trim class="bash">
# Instalar react-native-maps
npm install react-native-maps

# iOS - adicionar no Podfile
pod 'react-native-google-maps', path: '../node_modules/react-native-maps'

# Android - configurar API keys
# android/app/src/main/res/values/strings.xml
&lt;string name="google_maps_key"&gt;YOUR_API_KEY&lt;/string&gt;
          </code></pre>
        </section>
        <section>
          <h3>ğŸ“ Componente de Mapa Interativo</h3>
          <pre><code data-trim class="javascript">
import React, { useState, useEffect, useRef } from 'react';
import MapView, { Marker, Polyline, Circle } from 'react-native-maps';
import { View, Text, TouchableOpacity, Alert } from 'react-native';
import LocationService from '../services/LocationService';

function InteractiveMap() {
  const [userLocation, setUserLocation] = useState(null);
  const [markers, setMarkers] = useState([]);
  const [route, setRoute] = useState([]);
  const [isTracking, setIsTracking] = useState(false);
  const mapRef = useRef(null);

  useEffect(() => {
    initializeMap();
    
    return () => {
      LocationService.stopTracking();
    };
  }, []);

  const initializeMap = async () => {
    try {
      await LocationService.requestPermissions();
      const location = await LocationService.getCurrentLocation();
      setUserLocation(location);

      // Centralizar mapa na localizaÃ§Ã£o atual
      if (mapRef.current && location) {
        mapRef.current.animateToRegion({
          latitude: location.latitude,
          longitude: location.longitude,
          latitudeDelta: 0.01,
          longitudeDelta: 0.01,
        }, 1000);
      }

      // Subscrever Ã s atualizaÃ§Ãµes de localizaÃ§Ã£o
      LocationService.subscribe((newLocation) => {
        setUserLocation(newLocation);
        
        if (isTracking) {
          setRoute(prevRoute => [...prevRoute, {
            latitude: newLocation.latitude,
            longitude: newLocation.longitude
          }]);
        }
      });
    } catch (error) {
      Alert.alert('Erro', 'NÃ£o foi possÃ­vel acessar sua localizaÃ§Ã£o');
    }
  };

  const startTracking = async () => {
    try {
      await LocationService.startTracking({
        accuracy: Location.Accuracy.High,
        timeInterval: 3000,
        distanceInterval: 5
      });
      setIsTracking(true);
      setRoute([]); // Limpar rota anterior
    } catch (error) {
      Alert.alert('Erro', 'NÃ£o foi possÃ­vel iniciar o rastreamento');
    }
  };

  const stopTracking = async () => {
    await LocationService.stopTracking();
    setIsTracking(false);
  };

  const addMarker = (event) => {
    const { coordinate } = event.nativeEvent;
    const newMarker = {
      id: Date.now().toString(),
      coordinate,
      title: `Marcador ${markers.length + 1}`,
      description: `Lat: ${coordinate.latitude.toFixed(6)}, Lng: ${coordinate.longitude.toFixed(6)}`
    };
    
    setMarkers(prevMarkers => [...prevMarkers, newMarker]);
  };

  const calculateDistance = (coord1, coord2) => {
    // FÃ³rmula de Haversine para calcular distÃ¢ncia
    const R = 6371e3; // Earth radius in meters
    const Ï†1 = coord1.latitude * Math.PI / 180;
    const Ï†2 = coord2.latitude * Math.PI / 180;
    const Î”Ï† = (coord2.latitude - coord1.latitude) * Math.PI / 180;
    const Î”Î» = (coord2.longitude - coord1.longitude) * Math.PI / 180;

    const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
              Math.cos(Ï†1) * Math.cos(Ï†2) *
              Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c; // Distance in meters
  };

  return (
    &lt;View style={styles.container}&gt;
      {userLocation && (
        &lt;MapView
          ref={mapRef}
          style={styles.map}
          initialRegion={{
            latitude: userLocation.latitude,
            longitude: userLocation.longitude,
            latitudeDelta: 0.01,
            longitudeDelta: 0.01,
          }}
          showsUserLocation={true}
          showsMyLocationButton={true}
          followsUserLocation={isTracking}
          onLongPress={addMarker}
          mapType="standard"
        &gt;
          {/* Marcador da localizaÃ§Ã£o atual com precisÃ£o */}
          &lt;Marker
            coordinate={{
              latitude: userLocation.latitude,
              longitude: userLocation.longitude
            }}
            title="VocÃª estÃ¡ aqui"
            description={`PrecisÃ£o: ${userLocation.accuracy?.toFixed(1)}m`}
            pinColor="blue"
          /&gt;

          {/* CÃ­rculo de precisÃ£o */}
          {userLocation.accuracy && (
            &lt;Circle
              center={{
                latitude: userLocation.latitude,
                longitude: userLocation.longitude
              }}
              radius={userLocation.accuracy}
              fillColor="rgba(0, 122, 255, 0.2)"
              strokeColor="rgba(0, 122, 255, 0.5)"
            /&gt;
          )}

          {/* Marcadores adicionados pelo usuÃ¡rio */}
          {markers.map(marker => (
            &lt;Marker
              key={marker.id}
              coordinate={marker.coordinate}
              title={marker.title}
              description={marker.description}
            /&gt;
          ))}

          {/* Rota do rastreamento */}
          {route.length > 1 && (
            &lt;Polyline
              coordinates={route}
              strokeColor="#FF0000"
              strokeWidth={3}
              lineDashPattern={[5, 5]}
            /&gt;
          )}
        &lt;/MapView&gt;
      )}

      {/* Controles */}
      &lt;View style={styles.controls}&gt;
        &lt;TouchableOpacity
          style={[styles.button, isTracking && styles.buttonActive]}
          onPress={isTracking ? stopTracking : startTracking}
        &gt;
          &lt;Text style={styles.buttonText}&gt;
            {isTracking ? 'Parar Rastreamento' : 'Iniciar Rastreamento'}
          &lt;/Text&gt;
        &lt;/TouchableOpacity&gt;

        &lt;View style={styles.info}&gt;
          &lt;Text style={styles.infoText}&gt;
            Marcadores: {markers.length}
          &lt;/Text&gt;
          {route.length > 1 && (
            &lt;Text style={styles.infoText}&gt;
              DistÃ¢ncia: {calculateDistance(route[0], route[route.length - 1]).toFixed(0)}m
            &lt;/Text&gt;
          )}
        &lt;/View&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}
          </code></pre>
        </section>
      </section>

      <!-- Slide 7 - Sistema de Rotas -->
      <section>
        <h2>ğŸ›£ï¸ Sistema de Rotas e NavegaÃ§Ã£o</h2>
        <section>
          <h3>ğŸ—ºï¸ Directions API</h3>
          <pre><code data-trim class="javascript">
// services/DirectionsService.js
class DirectionsService {
  constructor() {
    this.apiKey = 'YOUR_GOOGLE_MAPS_API_KEY';
    this.baseUrl = 'https://maps.googleapis.com/maps/api/directions/json';
  }

  async getRoute(origin, destination, options = {}) {
    const {
      mode = 'driving', // driving, walking, bicycling, transit
      avoid = '', // tolls, highways, ferries, indoor
      units = 'metric',
      alternatives = false
    } = options;

    const params = new URLSearchParams({
      origin: `${origin.latitude},${origin.longitude}`,
      destination: `${destination.latitude},${destination.longitude}`,
      mode,
      avoid,
      units,
      alternatives,
      key: this.apiKey
    });

    try {
      const response = await fetch(`${this.baseUrl}?${params}`);
      const data = await response.json();

      if (data.status !== 'OK') {
        throw new Error(`Directions API error: ${data.status}`);
      }

      return this.parseDirectionsResponse(data);
    } catch (error) {
      console.error('Get route failed:', error);
      throw error;
    }
  }

  parseDirectionsResponse(data) {
    const route = data.routes[0];
    const leg = route.legs[0];

    return {
      coordinates: this.decodePolyline(route.overview_polyline.points),
      distance: leg.distance,
      duration: leg.duration,
      steps: leg.steps.map(step => ({
        instruction: step.html_instructions.replace(/<[^>]*>/g, ''),
        distance: step.distance,
        duration: step.duration,
        startLocation: step.start_location,
        endLocation: step.end_location,
        maneuver: step.maneuver
      })),
      bounds: route.bounds
    };
  }

  decodePolyline(encoded) {
    // Decodificar polyline do Google Maps
    let index = 0;
    const len = encoded.length;
    let lat = 0;
    let lng = 0;
    const coordinates = [];

    while (index < len) {
      let b;
      let shift = 0;
      let result = 0;
      do {
        b = encoded.charCodeAt(index++) - 63;
        result |= (b & 0x1f) << shift;
        shift += 5;
      } while (b >= 0x20);
      const dlat = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
      lat += dlat;

      shift = 0;
      result = 0;
      do {
        b = encoded.charCodeAt(index++) - 63;
        result |= (b & 0x1f) << shift;
        shift += 5;
      } while (b >= 0x20);
      const dlng = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
      lng += dlng;

      coordinates.push({
        latitude: lat / 1e5,
        longitude: lng / 1e5
      });
    }

    return coordinates;
  }

  async getNearbyPlaces(location, options = {}) {
    const {
      radius = 1000,
      type = 'point_of_interest',
      keyword = ''
    } = options;

    const params = new URLSearchParams({
      location: `${location.latitude},${location.longitude}`,
      radius,
      type,
      keyword,
      key: this.apiKey
    });

    try {
      const response = await fetch(
        `https://maps.googleapis.com/maps/api/place/nearbysearch/json?${params}`
      );
      const data = await response.json();

      if (data.status !== 'OK') {
        throw new Error(`Places API error: ${data.status}`);
      }

      return data.results.map(place => ({
        placeId: place.place_id,
        name: place.name,
        rating: place.rating,
        location: place.geometry.location,
        types: place.types,
        vicinity: place.vicinity,
        photos: place.photos
      }));
    } catch (error) {
      console.error('Get nearby places failed:', error);
      throw error;
    }
  }
}

export default new DirectionsService();
          </code></pre>
        </section>
        <section>
          <h3>ğŸ§­ NavegaÃ§Ã£o Turn-by-Turn</h3>
          <pre><code data-trim class="javascript">
// components/NavigationScreen.js
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, Alert } from 'react-native';
import MapView, { Polyline, Marker } from 'react-native-maps';
import DirectionsService from '../services/DirectionsService';
import LocationService from '../services/LocationService';

function NavigationScreen({ route }) {
  const { destination } = route.params;
  const [userLocation, setUserLocation] = useState(null);
  const [routeData, setRouteData] = useState(null);
  const [currentStepIndex, setCurrentStepIndex] = useState(0);
  const [isNavigating, setIsNavigating] = useState(false);

  useEffect(() => {
    initializeNavigation();
  }, []);

  const initializeNavigation = async () => {
    try {
      const location = await LocationService.getCurrentLocation();
      setUserLocation(location);

      const directions = await DirectionsService.getRoute(
        location,
        destination,
        { mode: 'driving' }
      );
      setRouteData(directions);

      // Iniciar tracking de localizaÃ§Ã£o
      LocationService.subscribe(handleLocationUpdate);
    } catch (error) {
      Alert.alert('Erro', 'NÃ£o foi possÃ­vel calcular a rota');
    }
  };

  const handleLocationUpdate = (newLocation) => {
    setUserLocation(newLocation);

    if (isNavigating && routeData) {
      // Verificar se chegou ao prÃ³ximo passo
      const currentStep = routeData.steps[currentStepIndex];
      if (currentStep) {
        const distanceToStep = calculateDistance(
          newLocation,
          currentStep.endLocation
        );

        // Se estÃ¡ prÃ³ximo do final do passo (< 20 metros)
        if (distanceToStep < 20 && currentStepIndex < routeData.steps.length - 1) {
          setCurrentStepIndex(prev => prev + 1);
          announceNextStep();
        }
      }
    }
  };

  const startNavigation = async () => {
    try {
      await LocationService.startTracking({
        accuracy: Location.Accuracy.BestForNavigation,
        timeInterval: 1000, // 1 segundo
        distanceInterval: 1  // 1 metro
      });
      setIsNavigating(true);
      announceNextStep();
    } catch (error) {
      Alert.alert('Erro', 'NÃ£o foi possÃ­vel iniciar a navegaÃ§Ã£o');
    }
  };

  const stopNavigation = async () => {
    await LocationService.stopTracking();
    setIsNavigating(false);
  };

  const announceNextStep = () => {
    if (routeData && currentStepIndex < routeData.steps.length) {
      const step = routeData.steps[currentStepIndex];
      // Implementar Text-to-Speech ou notificaÃ§Ã£o
      console.log('PrÃ³xima instruÃ§Ã£o:', step.instruction);
    }
  };

  const calculateDistance = (coord1, coord2) => {
    const R = 6371e3;
    const Ï†1 = coord1.latitude * Math.PI / 180;
    const Ï†2 = coord2.latitude * Math.PI / 180;
    const Î”Ï† = (coord2.latitude - coord1.latitude) * Math.PI / 180;
    const Î”Î» = (coord2.longitude - coord1.longitude) * Math.PI / 180;

    const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
              Math.cos(Ï†1) * Math.cos(Ï†2) *
              Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
  };

  if (!userLocation || !routeData) {
    return (
      &lt;View style={styles.loading}&gt;
        &lt;Text&gt;Calculando rota...&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  const currentStep = routeData.steps[currentStepIndex];

  return (
    &lt;View style={styles.container}&gt;
      {/* Mapa de navegaÃ§Ã£o */}
      &lt;MapView
        style={styles.map}
        region={{
          latitude: userLocation.latitude,
          longitude: userLocation.longitude,
          latitudeDelta: 0.01,
          longitudeDelta: 0.01,
        }}
        showsUserLocation={true}
        followsUserLocation={true}
        showsTraffic={true}
      &gt;
        {/* Rota completa */}
        &lt;Polyline
          coordinates={routeData.coordinates}
          strokeColor="#4285F4"
          strokeWidth={5}
        /&gt;

        {/* Marcador de destino */}
        &lt;Marker
          coordinate={destination}
          title="Destino"
          pinColor="red"
        /&gt;
      &lt;/MapView&gt;

      {/* Painel de instruÃ§Ãµes */}
      &lt;View style={styles.instructionPanel}&gt;
        {currentStep && (
          &lt;View&gt;
            &lt;Text style={styles.instruction}&gt;
              {currentStep.instruction}
            &lt;/Text&gt;
            &lt;Text style={styles.distance}&gt;
              {currentStep.distance.text} â€¢ {currentStep.duration.text}
            &lt;/Text&gt;
          &lt;/View&gt;
        )}

        {/* InformaÃ§Ãµes da rota */}
        &lt;View style={styles.routeInfo}&gt;
          &lt;Text style={styles.routeInfoText}&gt;
            Total: {routeData.distance.text} â€¢ {routeData.duration.text}
          &lt;/Text&gt;
        &lt;/View&gt;

        {/* Controles */}
        &lt;TouchableOpacity
          style={[styles.navButton, isNavigating && styles.navButtonActive]}
          onPress={isNavigating ? stopNavigation : startNavigation}
        &gt;
          &lt;Text style={styles.navButtonText}&gt;
            {isNavigating ? 'Parar NavegaÃ§Ã£o' : 'Iniciar NavegaÃ§Ã£o'}
          &lt;/Text&gt;
        &lt;/TouchableOpacity&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}
          </code></pre>
        </section>
      </section>

      <!-- Slide 8 - Sensores BiomÃ©tricos -->
      <section>
        <h2>ğŸ‘† Sensores BiomÃ©tricos</h2>
        <section>
          <h3>ğŸ” Local Authentication</h3>
          <pre><code data-trim class="javascript">
// expo install expo-local-authentication
import * as LocalAuthentication from 'expo-local-authentication';

class BiometricAuthService {
  async checkBiometricSupport() {
    try {
      // Verificar se dispositivo tem hardware biomÃ©trico
      const hasHardware = await LocalAuthentication.hasHardwareAsync();
      if (!hasHardware) {
        return { supported: false, reason: 'No biometric hardware' };
      }

      // Verificar se tem biometrias cadastradas
      const isEnrolled = await LocalAuthentication.isEnrolledAsync();
      if (!isEnrolled) {
        return { supported: false, reason: 'No biometrics enrolled' };
      }

      // Verificar tipos de autenticaÃ§Ã£o disponÃ­veis
      const supportedTypes = await LocalAuthentication.supportedAuthenticationTypesAsync();
      
      return {
        supported: true,
        types: supportedTypes.map(type => {
          switch (type) {
            case LocalAuthentication.AuthenticationType.FINGERPRINT:
              return 'fingerprint';
            case LocalAuthentication.AuthenticationType.FACIAL_RECOGNITION:
              return 'faceId';
            case LocalAuthentication.AuthenticationType.IRIS:
              return 'iris';
            default:
              return 'unknown';
          }
        })
      };
    } catch (error) {
      console.error('Biometric check failed:', error);
      return { supported: false, reason: error.message };
    }
  }

  async authenticateAsync(options = {}) {
    const {
      promptMessage = 'Authenticate to continue',
      cancelLabel = 'Cancel',
      fallbackLabel = 'Use Password',
      disableDeviceFallback = false
    } = options;

    try {
      const result = await LocalAuthentication.authenticateAsync({
        promptMessage,
        cancelLabel,
        fallbackLabel,
        disableDeviceFallback
      });

      if (result.success) {
        return {
          success: true,
          authType: this.getAuthenticationType(result)
        };
      } else {
        return {
          success: false,
          error: result.error,
          warning: result.warning
        };
      }
    } catch (error) {
      console.error('Biometric authentication failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  getAuthenticationType(result) {
    // Esta funÃ§Ã£o pode precisar ser adaptada baseada na versÃ£o do expo-local-authentication
    if (result.authenticationMethod) {
      return result.authenticationMethod;
    }
    return 'unknown';
  }

  async promptForBiometricSetup() {
    Alert.alert(
      'Configure Biometrics',
      'To use biometric authentication, please set up Face ID or Touch ID in your device settings.',
      [
        { text: 'Later', style: 'cancel' },
        { text: 'Settings', onPress: () => Linking.openSettings() }
      ]
    );
  }
}

// Hook para usar autenticaÃ§Ã£o biomÃ©trica
function useBiometricAuth() {
  const [biometricSupport, setBiometricSupport] = useState(null);
  const biometricService = new BiometricAuthService();

  useEffect(() => {
    checkSupport();
  }, []);

  const checkSupport = async () => {
    const support = await biometricService.checkBiometricSupport();
    setBiometricSupport(support);
  };

  const authenticate = async (options) => {
    if (!biometricSupport?.supported) {
      throw new Error('Biometric authentication not supported');
    }

    return await biometricService.authenticateAsync(options);
  };

  return {
    biometricSupport,
    authenticate,
    checkSupport
  };
}

// Componente de Login com Biometria
function BiometricLoginScreen() {
  const { biometricSupport, authenticate } = useBiometricAuth();
  const [isAuthenticating, setIsAuthenticating] = useState(false);

  const handleBiometricLogin = async () => {
    try {
      setIsAuthenticating(true);
      
      const result = await authenticate({
        promptMessage: 'Use your biometric to login',
        fallbackLabel: 'Use password instead'
      });

      if (result.success) {
        Alert.alert('Success', 'Authentication successful!');
        // Navegar para tela principal ou executar login
      } else {
        Alert.alert('Authentication Failed', result.error || 'Please try again');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    } finally {
      setIsAuthenticating(false);
    }
  };

  if (!biometricSupport) {
    return (
      &lt;View style={styles.center}&gt;
        &lt;Text&gt;Checking biometric support...&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  if (!biometricSupport.supported) {
    return (
      &lt;View style={styles.center}&gt;
        &lt;Text&gt;Biometric authentication not available&lt;/Text&gt;
        &lt;Text style={styles.subtitle}&gt;{biometricSupport.reason}&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Secure Login&lt;/Text&gt;
      
      &lt;TouchableOpacity
        style={[styles.biometricButton, isAuthenticating && styles.buttonDisabled]}
        onPress={handleBiometricLogin}
        disabled={isAuthenticating}
      &gt;
        &lt;Text style={styles.biometricIcon}&gt;
          {biometricSupport.types.includes('faceId') ? 'ğŸ‘¤' : 'ğŸ‘†'}
        &lt;/Text&gt;
        &lt;Text style={styles.biometricText}&gt;
          {isAuthenticating ? 'Authenticating...' : 'Use Biometric Login'}
        &lt;/Text&gt;
      &lt;/TouchableOpacity&gt;

      &lt;Text style={styles.supportedTypes}&gt;
        Supported: {biometricSupport.types.join(', ')}
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}
          </code></pre>
        </section>
      </section>

      <!-- Slide 9 - ExercÃ­cio PrÃ¡tico -->
      <section>
        <h2>ğŸ’» ExercÃ­cio PrÃ¡tico</h2>
        <section>
          <h3>ğŸ¯ Desafio: App de Fitness Tracker</h3>
          <p>Desenvolver aplicativo de fitness com sensores:</p>
          <ul>
            <li>ğŸ“ <strong>GPS Tracking:</strong> Rastrear corridas/caminhadas</li>
            <li>ğŸƒâ€â™‚ï¸ <strong>Motion Detection:</strong> Contar passos automÃ¡tico</li>
            <li>ğŸ—ºï¸ <strong>Route Mapping:</strong> Visualizar percurso no mapa</li>
            <li>ğŸ“Š <strong>Statistics:</strong> DistÃ¢ncia, velocidade, calorias</li>
            <li>ğŸ‘† <strong>Biometric Lock:</strong> Proteger dados pessoais</li>
            <li>ğŸ”„ <strong>Background Sync:</strong> Sincronizar atividades</li>
          </ul>
        </section>
        <section>
          <h3>ğŸ—ï¸ Funcionalidades ObrigatÃ³rias</h3>
          <ul>
            <li>â–¶ï¸ <strong>Start/Stop Workout:</strong> Controle de atividade</li>
            <li>â±ï¸ <strong>Real-time Stats:</strong> Tempo, distÃ¢ncia, pace</li>
            <li>ğŸ“± <strong>Background Tracking:</strong> Funcionar com tela bloqueada</li>
            <li>ğŸ¯ <strong>Goal Setting:</strong> Metas de distÃ¢ncia/tempo</li>
            <li>ğŸ“ˆ <strong>Progress Charts:</strong> GrÃ¡ficos de evoluÃ§Ã£o</li>
            <li>ğŸ† <strong>Achievements:</strong> Sistema de conquistas</li>
          </ul>
        </section>
        <section>
          <h3>âš¡ Requisitos TÃ©cnicos</h3>
          <ul>
            <li>ğŸ”‹ <strong>Battery Optimization:</strong> Uso eficiente de GPS</li>
            <li>ğŸ’¾ <strong>Local Storage:</strong> SQLite para histÃ³rico</li>
            <li>ğŸ”” <strong>Notifications:</strong> Marcos de progresso</li>
            <li>ğŸ¨ <strong>Responsive UI:</strong> AdaptaÃ§Ã£o a diferentes telas</li>
            <li>ğŸ” <strong>Data Security:</strong> Proteger informaÃ§Ãµes sensÃ­veis</li>
            <li>ğŸ“Š <strong>Performance:</strong> < 2s para iniciar tracking</li>
          </ul>
        </section>
      </section>

      <!-- Slide 10 - Resumo e PrÃ³ximos Passos -->
      <section>
        <h2>ğŸ“ Resumo da Aula</h2>
        <section>
          <h3>âœ… O que Vimos Hoje</h3>
          <ul>
            <li>ğŸ“ GeolocalizaÃ§Ã£o precisa com Expo Location</li>
            <li>ğŸƒâ€â™‚ï¸ Sensores de movimento (acelerÃ´metro, giroscÃ³pio)</li>
            <li>ğŸ—ºï¸ IntegraÃ§Ã£o com React Native Maps</li>
            <li>ğŸ›£ï¸ Sistema de rotas e navegaÃ§Ã£o turn-by-turn</li>
            <li>ğŸ‘† AutenticaÃ§Ã£o biomÃ©trica com Local Auth</li>
            <li>âš¡ OtimizaÃ§Ã£o de bateria e performance</li>
          </ul>
        </section>
        <section>
          <h3>ğŸš€ PrÃ³xima Aula</h3>
          <h4>Aula 7: Debug e InspeÃ§Ã£o de CÃ³digo</h4>
          <ul>
            <li>ğŸ› Ferramentas de debugging avanÃ§ado</li>
            <li>ğŸ“Š Performance profiling</li>
            <li>ğŸ” Code inspection e anÃ¡lise estÃ¡tica</li>
            <li>âš¡ OtimizaÃ§Ã£o de performance final</li>
          </ul>
        </section>
        <section>
          <h3>ğŸ“š Tarefa de Casa</h3>
          <ul>
            <li>ğŸƒâ€â™‚ï¸ Implemente o Fitness Tracker completo</li>
            <li>ğŸ“ Configure tracking em background</li>
            <li>ğŸ—ºï¸ Integre mapas e navegaÃ§Ã£o</li>
            <li>ğŸ‘† Adicione autenticaÃ§Ã£o biomÃ©trica</li>
            <li>ğŸ“Š Teste performance com uso prolongado</li>
          </ul>
        </section>
      </section>

   </div>
  </div>

  
  <script src="../../../../reveal.js-master/dist/reveal.js"></script>
  <script src="../../../../reveal.js-master/plugin/zoom/zoom.js"></script>
  <script src="../../../../reveal.js-master/plugin/notes/notes.js"></script>
  <script src="../../../../reveal.js-master/plugin/search/search.js"></script>
  <script src="../../../../reveal.js-master/plugin/markdown/markdown.js"></script>
  <script src="../../../../reveal.js-master/plugin/highlight/highlight.js"></script>
  <script>
    Reveal.initialize({
      controls: true,
      progress: true,
      center: true,
      hash: true,
      slideNumber: true,
      plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
    });
  </script>
</body>

</html>
