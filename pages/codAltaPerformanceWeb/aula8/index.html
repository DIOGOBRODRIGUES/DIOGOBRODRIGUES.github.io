<!doctype html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8">
    <title>Aula 8: Gerenciamento de Estado com Hook</title>

    <meta name="description" content="Aula 8 de Programa√ß√£o Web: Gerenciamento de Estado com Hook">
    <meta name="author" content="Prof. Dr. Diogo Francisco Borba Rodrigues">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="../../../reveal.js-master/dist/reset.css">
    <link rel="stylesheet" href="../../../reveal.js-master/dist/reveal.css">
    <link rel="stylesheet" href="../../../reveal.js-master/dist/theme/dracula.css" id="theme">

    <!-- Syntax Highlighting -->
    <link rel="stylesheet" href="../../../reveal.js-master/plugin/highlight/monokai.css">
</head>

<body>

    <div class="reveal">
        <div class="slides">
            <!-- Slide 1 - T√≠tulo da Aula -->
            <section>
                <p>üèõÔ∏è Centro Universit√°rio Maur√≠cio de Nassau</p>
                <h3>Aula 8: Gerenciamento de Estado com Hook</h3>
                <p>Prof. Dr. Diogo Francisco Borba Rodrigues</p>
                <a href="https://www.linkedin.com/in/diogo-francisco-borba-rodrigues-3a1b5179/" target="_blank"><i
                        class="fab fa-linkedin"></i> </a>
                <a href="https://github.com/DIOGOBRODRIGUES" target="_blank"><i class="fab fa-github"></i> </a>
            </section>

            <!--Slide 2 Respondendo a eventos-->
            <section>
                <h2>Respondendo a eventos</h2>
                <p>
                    O React permite que voc√™ adicione manipuladores de eventos ao seu JSX. Os manipuladores de eventos
                    s√£o fun√ß√µes que ser√£o acionadas em resposta a intera√ß√µes como clicar, passar o mouse, focar entradas
                    de formul√°rio e assim por diante.
                </p>
            </section>

            <!--Slide 3 Adicionando manipuladores-->
            <section>
                <h2>Adicionando manipuladores de eventos</h2>
                <p>
                    Para adicionar um manipulador de eventos, voc√™ deve definir uma fun√ß√£o e pass√°-la como prop para a
                    tag JSX apropriada.
                </p>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim >
              export default function Button() {
                return (
                  <button>
                    I don't do anything
                  </button>
                );
              }
                </code></pre>
            </section>

            <!--Slide 4 Fazendo algo com o evento-->
            <section>
                <h2>Fazendo algo com o evento</h2>
                <p>
                    Para exibir uma mensagem ao clicar, siga estes passos:
                </p>
                <ol>
                    <li>Declare uma fun√ß√£o <code>handleClick</code> no componente.</li>
                    <li>Adicione a l√≥gica dentro da fun√ß√£o (use <code>alert</code>).</li>
                    <li>Adicione <code>onClick={handleClick}</code> ao <code>&lt;button&gt;</code> JSX.</li>
                </ol>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
                  export default function Button() {
                    function handleClick() {
                      alert('Voc√™ clicou no bot√£o!');
                    }
                  
                    return (
                      <button onClick={handleClick}>
                        Clique neste bot√£o
                      </button>
                    );
                  }
                </code></pre>
            </section>

            <!--Slide 5 Usando Manipuladores inline-->
            <section>
                <h2>Usando manipuladores inline</h2>
                <p>
                    Voc√™ pode definir manipuladores de eventos inline com fun√ß√µes an√¥nimas:
                </p>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                                export default function Button() {
                                
                                return (
                                  <button onClick={() => alert('You clicked me!')}>
                                    Click me
                                  </button>
                                );
                                }
            </script></code></pre>
            </section>

            <!--Slide 6 Passando fun√ß√µes corretamente-->
            <section>
                <h2>Passando fun√ß√µes corretamente</h2>
                <p>N√£o passe a fun√ß√£o diretamente como <code>onClick={handleClick()}</code>. Ao inv√©s disso, fa√ßa assim:
                </p>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                  <button onClick={handleClick}>   // Correto

                  <button onClick={handleClick()}> // Incorreto
                </script></code></pre>
                <p>
                    Fun√ß√µes devem ser passadas, n√£o chamadas diretamente, para evitar que elas sejam executadas durante
                    a renderiza√ß√£o.
                </p>
            </section>

            <!--Slide 7 Lendo props em manipuladores de eventos-->
            <section>
                <h2>Lendo props em manipuladores de eventos</h2>
                <p>
                    Manipuladores de eventos t√™m acesso aos <code>props</code> do componente:
                </p>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-7|9-19"><script type="text/template">
               function AlertButton({ message, children }) {
                return (
                  <button onClick={() => alert(message)}>
                    {children}
                  </button>
                );
              }
              
              export default function Toolbar() {
                return (
                  <div>
                    <AlertButton message="Playing!">
                      Play Movie  //children
                    </AlertButton>
                    <AlertButton message="Uploading!">
                      Upload Image // children
                    </AlertButton>
                  </div>
                );
              }
            </script></code></pre>
            </section>

            <!--Slide 8 children-->
            <section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
                <h2>üìå Lembrete</h2>
                <p>
                    o par√¢metro <code>children</code> √© uma prop especial em React que √© usada para representar o conte√∫do que √© passado entre as tags de abertura e fechamento de um componente.
                </p>
            </section>

            <!--Slide 9 Estado: Mem√≥ria de um Componente-->
            <section>
                <h2>Estado: Mem√≥ria de um Componente</h2>
                <p>
                  Os componentes geralmente precisam mudar o que est√° na tela como resultado de uma intera√ß√£o. Por exemplo, ao digitar em um formul√°rio ou ao clicar em um bot√£o de "pr√≥ximo" em um carrossel de imagens.
                </p>
                <p>
                  No React, essa "mem√≥ria" espec√≠fica de um componente √© chamada de <strong>estado</strong>.
                </p>
              </section>
             <!--Slide 10 useState-->
              <section>
                <h2>Quando uma vari√°vel regular n√£o √© suficiente</h2>
                <p>
                  Um componente que renderiza uma galeria de imagens, onde clicar em ‚ÄúNext‚Äù deve alterar a imagem, mas uma vari√°vel local <code>index</code> n√£o persiste entre renderiza√ß√µes e n√£o aciona re-renderiza√ß√£o.
                </p>
            
              </section>

              <!--Slide 11 useState-->
              <section>
                <h2>Quando uma vari√°vel regular n√£o √© suficiente</h2>
             
                <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers><script type="text/template">
              export default function Gallery() {
                let index = 0;
              
                function handleClick() {
                  index = index + 1;
                }
              
                let sculpture = sculptureList[index];
                return (
                  <>
                    <button onClick={handleClick}>Next</button>
                    <h2>{sculpture.name}</h2>
                  </>
                );
              }
            </script></code></pre>
              </section>
            <!--Slide 12 useState-->
              <section>
                <h2>Adicionando uma vari√°vel de estado</h2>
                <p>
                  Para persistir a vari√°vel entre renderiza√ß√µes, √© necess√°rio usar o Hook <code>useState</code> para criar o estado:
                </p>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers><script type="text/template">

              import { useState } from 'react';
              
              export default function Gallery() {
                const [index, setIndex] = useState(0);
              
                function handleClick() {
                  setIndex(index + 1);
                }
            </script></code></pre>
              </section>
            <!--Slide 13 useState-->
              <section>
                <h2>Conhe√ßa seu primeiro Hook: <code>useState</code></h2>
                <p>
                  O <code>useState</code> √© um Hook que cria uma vari√°vel de estado e uma fun√ß√£o que a atualiza. 
                </p>
                <p>
                  Exemplo:
                </p>
                <pre><code>
              const [index, setIndex] = useState(0);
                </code></pre>
                <p>
                  Esse c√≥digo inicializa a vari√°vel <code>index</code> com valor <code>0</code> e retorna uma fun√ß√£o <code>setIndex</code> para atualiz√°-la.
                </p>
              </section>
            <!--Slide 14 useState-->
              <section>
                <h2>Exemplo completo: Galeria de Imagens</h2>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-9|11-17"><script type="text/template">
              import { useState } from 'react';
              import { sculptureList } from './data.js';
              
              export default function Gallery() {
                const [index, setIndex] = useState(0);
              
                function handleClick() {
                  setIndex(index + 1);
                }
              
                let sculpture = sculptureList[index];
                return (
                  <>
                    <button onClick={handleClick}>Next</button>
                    <h2>{sculpture.name} by {sculpture.artist}</h2>
                    <img src={sculpture.url} alt={sculpture.alt} />
                  </>
                );
              }
            </script></code></pre>
              </section>
            
              <!--Slide 15 useState-->
              <section>
                <h2>Dando a um componente m√∫ltiplas vari√°veis de estado</h2>
                <p>
                  Voc√™ pode ter quantas vari√°veis de estado desejar. No exemplo a seguir,  temos um √≠ndice <code>index</code> e uma vari√°vel booleana <code>showMore</code> que alterna a exibi√ß√£o de detalhes.
                </p>
                
              </section>


              <!--Slide 16 useState-->
              <section>
                <h2>Dando a um componente m√∫ltiplas vari√°veis de estado</h2>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-13|15-23"><script type="text/template">
              import { useState } from 'react';
              
              export default function Gallery() {
                const [index, setIndex] = useState(0);
                const [showMore, setShowMore] = useState(false);
              
                function handleNextClick() {
                  setIndex(index + 1);
                }
              
                function handleMoreClick() {
                  setShowMore(!showMore);
                }
              
                return (
                  <>
                    <button onClick={handleNextClick}>Next</button>
                    <button onClick={handleMoreClick}>
                      {showMore ? 'Hide' : 'Show'} details
                    </button>
                    {showMore && <p>More details here...</p>}
                  </>
                );
              }
            </script></code></pre>
              </section>

              <section>
                <h2>Ex√©ricios</h2>
                <p>Pr√°tique com alguns desafios  <a href="https://react.dev/learn/state-a-components-memory#challenges" target="_blank">aqui</a></p>
              </section>

              <!--Slide 17 Renderizar e Confirmar-->
              <section>
                <h2>Renderizar e Commit</h2>
                <p>
                  Antes que seus componentes sejam exibidos na tela, eles devem ser renderizados pelo React. 
                  Este processo de renderiza√ß√£o passa por tr√™s etapas:
                </p>
                <ol>
                  <li>Acionar uma renderiza√ß√£o</li>
                  <li>Renderiza√ß√£o do componente</li>
                  <li>Confirmando no DOM</li>
                </ol>
              </section>
            
              <!--Slide 18 Renderizar e Confirmar-->
              <section>
                <h2>Etapa 1: Acionar uma renderiza√ß√£o</h2>
                <p>H√° dois motivos para um componente ser renderizado:</p>
                <ul>
                  <li>√â a renderiza√ß√£o inicial do componente.</li>
                  <li>O estado do componente (ou de um de seus ancestrais) foi atualizado.</li>
                </ul>
                <p>
                  Exemplo de renderiza√ß√£o inicial:
                </p>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
              import { createRoot } from 'react-dom/client';
              import Image from './Image';
              
              const root = createRoot(document.getElementById('root'));
              root.render(<Image />);
                </script> </code></pre>
              </section>
              <!--Slide 19 Renderizar e Confirmar-->
              <section>
                <h2>Etapa 2: React Renderiza seus Componentes</h2>
                <p>
                  Ap√≥s disparar uma renderiza√ß√£o, o React chama seus componentes para descobrir o que exibir na tela.
                </p>
                <p>
                  Para renderiza√ß√µes subsequentes, o React chama o componente que acionou a atualiza√ß√£o de estado.
                </p>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
              export default function Gallery() {
                return (
                  <section>
                    <h1>Inspiring Sculptures</h1>
                    <Image />
                    <Image />
                    <Image />
                  </section>
                );
              }
            </script></code></pre>
              </section>
              <!--Slide 20 Renderizar e Confirmar-->
              <section>
                <h2>A Renderiza√ß√£o deve ser Pura</h2>
                <ul>
                  <li>
                    <strong>Mesmas entradas, mesma sa√≠da</strong>: Um componente deve sempre retornar o mesmo JSX para as mesmas entradas.
                  </li>
                  <li>
                    <strong>Cuida da sua pr√≥pria vida</strong>: Um componente n√£o deve alterar objetos ou vari√°veis externas.
                  </li>
                </ul>
                <p>
                  Isso ajuda a evitar bugs confusos e comportamento imprevis√≠vel.
                </p>
              </section>
              <!--Slide 21 Renderizar e Confirmar-->
              <section>
                <h2>Etapa 3: Confirmar as Altera√ß√µes no DOM</h2>
                <p>
                  Depois de renderizar os componentes, o React modifica o DOM:
                </p>
                <ul>
                  <li>
                    Para a renderiza√ß√£o inicial, ele usa <code>appendChild()</code> para adicionar os n√≥s DOM criados √† tela.
                  </li>
                  <li>
                    Para re-renderiza√ß√µes, o React aplica as m√≠nimas mudan√ßas necess√°rias para sincronizar o DOM com a sa√≠da de renderiza√ß√£o.
                  </li>
                </ul>
              </section>
                <!--Slide 22 Renderizar e Confirmar-->
              <section>
                <h2>Exemplo: Re-renderiza√ß√£o Controlada</h2>
                <p>
                  O React re-renderiza apenas as partes do DOM que mudaram:
                </p>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
              export default function Clock({ time }) {
                return (
                  <>
                    <h1>{time}</h1>
                    <input />
                  </>
                );
              }
            </script></code></pre>
                <p>
                  O React atualiza apenas o conte√∫do do <code>&lt;h1&gt;</code> com o novo <code>time</code>, mas n√£o toca no <code>&lt;input&gt;</code>.
                </p>
              </section>
              <!--Slide 23 Renderizar e Confirmar-->
              <section>
                <h2>Ep√≠logo: Pintura do Navegador</h2>
                <p>
                  Ap√≥s o React modificar o DOM, o navegador "pinta" as altera√ß√µes na tela. 
                  Esse processo √© conhecido como renderiza√ß√£o do navegador ou "pintura".
                </p>
              </section>
              <!--Slide 24 Estado como um Instant√¢neo-->
              <section>
                <h2>Estado como um Snapshot</h2>
                <p>
                    Vari√°veis ‚Äã‚Äãde estado podem parecer vari√°veis ‚Äã‚ÄãJavaScript comuns que voc√™ pode ler e escrever. No entanto, o estado se comporta mais como um snapshot. Defini-lo n√£o altera a vari√°vel de estado que voc√™ j√° tem, mas, em vez disso, aciona uma nova renderiza√ß√£o.
                </p>
              </section>
              <!--Slide 25 Definir Gatilhos de Estado-->
              <section>
                <h2>Definir Gatilhos de Estado</h2>
                <p>
                  Definir o estado aciona uma nova renderiza√ß√£o do componente, atualizando a interface do usu√°rio com o novo valor de estado.
                </p>
                <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-3|6-14|16-21|23-35|37-49"><script type="text/template">
                    /* Importa o hook useState do React, usado para gerenciar 
                    o estado no componente.*/
                    import { useState } from 'react';
                    
            
                    export default function Form() {
                      
                      /* Declara duas vari√°veis de estado: isSent e message.
                        isSent controla se a mensagem j√° foi enviada (valor
                        inicial: false). setIsSent √© a fun√ß√£o usada para alterar
                        o valor de isSent. message armazena o conte√∫do da 
                        mensagem  (valor inicial: 'Hi!').*/
                      const [isSent, setIsSent] = useState(false);
                      const [message, setMessage] = useState('Hi!');
                    
                      /* Verifica se a mensagem j√° foi enviada.
                       Se isSent for true, exibe uma mensagem de confirma√ß√£o e 
                       interrompe a renderiza√ß√£o do restante do componente.*/
                      if (isSent) {
                        return <h1>Your message is on its way!</h1>; 
                      }
                    
                      // Renderiza o formul√°rio, caso a mensagem ainda n√£o tenha sido enviada.
                      return (
                        <form onSubmit={(e) => {
                          <!--Previne o comportamento padr√£o do formul√°rio 
                          de recarregar a p√°gina.*/-->
                          e.preventDefault();
                          /*Atualiza o estado de isSent para true, indicando
                           que a mensagem foi enviada */
                          setIsSent(true); 
                          /*Chama uma fun√ß√£o (n√£o definida no c√≥digo) para enviar 
                          a mensagem.*/
                          sendMessage(message); 
                        }}>
                          
                          /* Renderiza um campo de texto para o usu√°rio digitar
                           a mensagem. */
                          <textarea
                          //Texto que aparece quando o campo est√° vazio
                            placeholder="Message" 
                            // O valor do textarea est√° vinculado ao estado 'message'.
                            value={message} 
                            // Atualiza o estado 'message' conforme o usu√°rio digita.
                            onChange={e => setMessage(e.target.value)} 
                          />
                          
                          /* Renderiza o bot√£o de enviar */
                          <button type="submit">Send</button>
                        </form>
                      );
                    }
            </script></code></pre>
              </section> 
             
              <!--Slide 26 Definir Gatilhos de Estado-->
              <section>
                <h2>Renderiza√ß√£o como um Snapshot</h2>
                <p>
                  Quando o React renderiza um componente, ele captura um "instant√¢neo" da interface. Esse snapshot √© interativo e cont√©m manipuladores de eventos calculados a partir do estado atual.
                </p>
              </section>

               <!--Slide 26 Definir Gatilhos de Estado-->
               <section>
                <h2>Renderiza√ß√£o como um Snapshot</h2>
                <img src="imagens/hookreact1.png">
              </section>

              <!--Slide 27 Definir Gatilhos de Estado-->
              <section>
                <img src="imagens/hookreact2.png">
              </section>


              <!--Slide 28 Estado "Fixado" Durante a Renderiza√ß√£o-->
              <section>
                <h2>Estado "Fixado" Durante a Renderiza√ß√£o</h2>
                <p>
                  O valor de uma vari√°vel de estado n√£o muda dentro de uma renderiza√ß√£o. Mesmo que um evento seja ass√≠ncrono, ele usa o valor do estado capturado no momento da renderiza√ß√£o.
                </p>
               
              </section>

                <!--Slide 29 Estado "Fixado" Durante a Renderiza√ß√£o-->
                <section>
                    <h2>Estado "Fixado" Durante a Renderiza√ß√£o</h2>
                  
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|3-4|8-13"><script type="text/template">
                  import { useState } from 'react';
                  
                  export default function Counter() {
                    const [number, setNumber] = useState(0);
                  
                    return (
                      <>
                        <h1>{number}</h1>
                        <button onClick={() => {
                          setNumber(number + 1);
                          setNumber(number + 1);
                          setNumber(number + 1);
                        }}>+3</button>
                      </>
                    );
                  }
                </script></code></pre>
                  </section>
                  <!--Slide 30 Estado "Fixado" Durante a Renderiza√ß√£o-->
                  <section>
                    <h2>Exemplo: Snapshot e Tempo</h2>
                    <p>
                      Mesmo com eventos ass√≠ncronos, o estado usado no manipulador √© o que estava presente no momento da renderiza√ß√£o:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers"><script type="text/template">                       
                    import { useState } from 'react';
                  
                    export default function Counter() {
                    const [number, setNumber] = useState(0);
                  
                    return (
                      <>
                        <h1>{number}</h1>
                        <button onClick={() => {
                          setNumber(number + 5);
                          setTimeout(() => {
                            alert(number);
                          }, 3000);
                        }}>+5</button>
                      </>
                    );
                  }
                </script></code></pre>
                  </section>

                  <!--Slide 31 Estado "Fixado" Durante a Renderiza√ß√£o-->
                <section>
                    <h2>Exerc√≠cios</h2>
                    <p>Pratique com alguns desafios <a href=" https://react.dev/learn/state-as-a-snapshot#implement-a-traffic-light"
                            target="_blank">aqui</a></p>
                </section>

                <!--Slide 32 Estado "Fixado" Durante a Renderiza√ß√£o-->
                <section>
                    <h2>Enfileirando uma S√©rie de Atualiza√ß√µes de Estado</h2>
                    <p>
                        Definir uma vari√°vel de estado enfileira uma nova renderiza√ß√£o, mas as atualiza√ß√µes s√≥ s√£o processadas ap√≥s todo
                        o c√≥digo no manipulador de eventos ser executado.
                    </p>
                </section>

                  <!--Slide 33 Estado "Fixado" Durante a Renderiza√ß√£o-->
                  <section>
                    <h2>Agrupamento de Atualiza√ß√µes de Estado (Batching)</h2>
                    <p>
                      O React agrupa (faz batching) atualiza√ß√µes de estado dentro de um manipulador de eventos, aplicando todas de uma vez ap√≥s a execu√ß√£o do c√≥digo.
                    </p>
                    <p>
                      Isso melhora o desempenho e evita renderiza√ß√µes "meio acabadas".
                    </p>
                  </section>

                  <!--Slide 34 Estado "Fixado" Durante a Renderiza√ß√£o-->
                <section>
                    <h2>Atualizando o Mesmo Estado V√°rias Vezes</h2>
                    <p>
                        Para atualizar o estado v√°rias vezes antes da pr√≥xima renderiza√ß√£o, voc√™ pode usar uma fun√ß√£o de atualiza√ß√£o.
                    </p>
                </section>

                 <!--Slide 34 Estado "Fixado" Durante a Renderiza√ß√£o-->
                 <section>
                     <h2>Atualizando o Mesmo Estado V√°rias Vezes</h2>
                     <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers><script type="text/template">
                                   import { useState } from 'react';
                                   
                                   export default function Counter() {
                                     const [number, setNumber] = useState(0);
                                   
                                     return (
                                       <>
                                         <h1>{number}</h1>
                                         <button onClick={() => {
                                           setNumber(n => n + 1);
                                           setNumber(n => n + 1);
                                           setNumber(n => n + 1);
                                         }}>+3</button>
                                       </>
                                     );
                                   }
                                   </script></code></pre>
                 </section>

                 <!--Slide 35 Funcoes de atualizacao em serie -->
                <section>
                    <h2>Fun√ß√µes de Atualiza√ß√£o em S√©rie</h2>
                    <p>
                        O React processa as fun√ß√µes de atualiza√ß√£o em s√©rie, passando o valor atualizado para cada fun√ß√£o subsequente:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers"><script type="text/template">
                                  atualiza√ß√£o em fila     n     retorna
                                  n => n + 1              0     1
                                  n => n + 1              1     2
                                  n => n + 1              2     3
                                  </script></code></pre>
                </section>

                <!--Slide 36 Misturando Atualiza√ß√µes e Substitui√ß√µes de Estado-->
                <section>
                    <h2>Misturando Atualiza√ß√µes e Substitui√ß√µes de Estado</h2>
                    <p>
                        O que acontece quando voc√™ mistura atualiza√ß√µes com fun√ß√µes e substitui√ß√µes diretas? Veja o exemplo:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers><script type="text/template">
                                  <button onClick={() => {
                                    setNumber(number + 5);
                                    setNumber(n => n + 1);
                                  }}>Increase the number</button>
                                  </script></code></pre>
                    <p>Resultado:</p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers><script type="text/template">
                                  "substituir por 5"      0    5
                                  n => n + 1              5    6
                                  </script></code></pre>
                </section>

                <!--Slide 37 Substituindo o Estado Ap√≥s Atualiz√°-lo-->
                <section>
                    <h2>Substituindo o Estado Ap√≥s Atualiz√°-lo</h2>
                    <p>
                        Se voc√™ substituir o estado ap√≥s uma atualiza√ß√£o, o React aplica a √∫ltima substitui√ß√£o:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers"><script type="text/template">
                                  <button onClick={() => {
                                    setNumber(number + 5);
                                    setNumber(n => n + 1);
                                    setNumber(42);
                                  }}>Increase the number</button>
                                  </script></code></pre>
                    <p>Resultado:</p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers"><script type="text/template">
                                  "substituir por 5"      0    5
                                  n => n + 1              5    6
                                  "substituir por 42"     6    42
                                  </script></code></pre>
                </section>

                <!--Slide 38 Conven√ß√µes de Nomenclatura de Fun√ß√µes de Atualiza√ß√£o-->
                <section>
                    <h2>Conven√ß√µes de Nomenclatura de Fun√ß√µes de Atualiza√ß√£o</h2>
                    <p>
                        As fun√ß√µes de atualiza√ß√£o geralmente usam a primeira letra da vari√°vel de estado ou seu nome completo. Exemplo:
                    </p>
                    <ul>
                        <li><code>setEnabled(e => !e);</code></li>
                        <li><code>setFriendCount(fc => fc * 2);</code></li>
                        <li><code>setLastName(prevLastName => prevLastName.reverse());</code></li>
                    </ul>
                </section>

                <!-- Slide 39 Ex√©rcios-->
                <section>
                    <h2>Exerc√≠cios</h2>
                    <p>Pratique com alguns desafios <a href="https://react.dev/learn/queueing-a-series-of-state-updates#challenges"
                            target="_blank">aqui</a></p>
                </section>

                <!--Slide 40 Atualizando Objetos no Estado-->
                <section>
                    <h2>Atualizando Objetos no Estado</h2>
                    <p>
                      O estado no React pode conter objetos JavaScript. No entanto, voc√™ n√£o deve alterar esses objetos diretamente. Em vez disso, crie um novo objeto ou fa√ßa uma c√≥pia de um existente e, em seguida, atualize o estado com essa c√≥pia.
                    </p>
                  </section>

                  <!--Slide 41 Atualizando Objetos no Estado-->
                  <section>
                    <h2>O Que √© uma Muta√ß√£o?</h2>
                    <p>
                      Objetos no estado React podem ser mut√°veis, mas voc√™ deve trat√°-los como imut√°veis. Muta√ß√£o √© quando voc√™ modifica diretamente um objeto existente no estado:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers><script type="text/template">
                  const [position, setPosition] = useState({ x: 0, y: 0 });
                  position.x = 5;
                  </script></code></pre>
                    <p>Isso n√£o aciona uma nova renderiza√ß√£o no React, ent√£o n√£o √© recomendado.</p>
                  </section>

                <!--Slide 42 Atualizando Objetos no Estado-->
                <section>
                    <h2>Tratar o Estado como Somente Leitura</h2>
                    <p>
                        Voc√™ deve sempre tratar o estado como somente leitura. Para atualizar o estado corretamente, crie um novo objeto
                        e passe-o para a fun√ß√£o de atualiza√ß√£o do estado:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                                  onPointerMove={e => {
                                    setPosition({
                                      x: e.clientX,
                                      y: e.clientY
                                    });
                                  }}
                                  </script></code></pre>
                </section>

                <!--Slide 43 Atualizando Objetos no Estado-->
                <section>
                    <h2>Muta√ß√£o Local √© Boa</h2>
                    <p>
                        Mutar objetos que voc√™ acabou de criar localmente √© aceit√°vel, porque nenhum outro c√≥digo faz refer√™ncia a eles
                        ainda:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                                  const nextPosition = { x: e.clientX, y: e.clientY };
                                  setPosition(nextPosition);
                                  </script></code></pre>
                </section>

                <!--Slide 44 Copiando Objetos com a Sintaxe Spread-->
                <section>
                    <h2>Copiando Objetos com a Sintaxe Spread</h2>
                    <p>
                        Voc√™ pode usar a sintaxe spread para copiar o conte√∫do de um objeto e alterar apenas o que for necess√°rio:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                                  setPerson({
                                    ...person, 
                                    firstName: e.target.value
                                  });
                                  </script></code></pre>
                </section>

                <!--Slide 46 objeto aninhado -->
                <section>
                    <h2>Atualizando um Objeto Aninhado</h2>
                    <p>
                        Para atualizar objetos aninhados, voc√™ precisa usar a sintaxe spread em m√∫ltiplos n√≠veis:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers><script type="text/template">
                                  setPerson({
                                    ...person,
                                    artwork: {
                                      ...person.artwork,
                                      city: 'New Delhi'
                                    }
                                  });
                                  </script></code></pre>
                </section>

                <!--Slide 47 Por que a Muta√ß√£o de Estado n√£o √© Recomendada no React?-->
                <section>
                    <h2>Por que a Muta√ß√£o de Estado n√£o √© Recomendada no React?</h2>
                    <ul>
                        <li><strong>Depura√ß√£o:</strong> Logs anteriores n√£o s√£o afetados pelas mudan√ßas mais recentes no estado.</li>
                        <li><strong>Otimiza√ß√µes:</strong> Verificar se o estado foi alterado √© mais r√°pido e f√°cil.</li>
                        <li><strong>Novo Recursos:</strong> Recursos futuros do React dependem do estado ser tratado como um snapshot.
                        </li>
                    </ul>
                </section>

                <!--Slide 48 Atualizando Arrays no Estado-->
                <section>
                    <h2>Atualizando Arrays no Estado</h2>
                    <p>
                      Arrays em JavaScript s√£o mut√°veis, mas quando armazenados no estado React, voc√™ deve trat√°-los como imut√°veis. Sempre que precisar atualizar um array, crie uma c√≥pia do original e use a fun√ß√£o de configura√ß√£o de estado para definir o novo array.
                    </p>
                  </section>
                
                  <!--Slide 49 Atualizando Arrays no Estado-->
                <section>
                  <h2>Atualizando Arrays Sem Muta√ß√£o</h2>
                  <p>
                    Assim como objetos, arrays devem ser tratados como somente leitura. Evite m√©todos que mutam a array, como <code>push()</code> e <code>pop()</code>. Use m√©todos como <code>filter()</code> e <code>map()</code> para criar novas arrays.
                  </p>
                  <p><strong>Tabela de m√©todos:</strong></p>
                  <ul>
                    <li><strong>Evitar:</strong> <code>push</code>, <code>pop</code>, <code>splice</code></li>
                    <li><strong>Preferir:</strong> <code>concat</code>, <code>filter</code>, <code>map</code></li>
                  </ul>
                </section>

                <!--Slide 50 Atualizando Arrays no Estado-->
                <section>
                    <h2>Adicionando a um Array</h2>
                    <p>
                      Evite usar <code>push()</code>, que muta a array. Em vez disso, crie uma nova array usando a sintaxe de propaga√ß√£o:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                  setArtists([
                    ...artists, // Copia os itens antigos
                    { id: nextId++, name: name } // Adiciona o novo item
                  ]);
                  </script></code></pre>
                </section>

                <!--Slide 51 Atualizando Arrays no Estado-->
                <section>
                    <h2>Removendo de um Array</h2>
                    <p>
                      Para remover um item de um array sem mut√°-lo, use <code>filter()</code> para produzir uma nova array sem o item desejado:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                  setArtists(artists.filter(a => a.id !== artist.id));
                  </script></code></pre>
                </section>

                <!--Slide 52 Atualizando Arrays no Estado-->
                <section>
                    <h2>Modificando um Item em um Array</h2>
                    <p>
                      Para substituir um item no array, use <code>map()</code> para criar uma nova array com o item modificado:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim><script type="text/template">
                  setCounters(counters.map((c, i) => {
                    return i === index ? c + 1 : c;
                  }));
                  </script></code></pre>
                </section>

                <!--Slide 53 Atualizando Arrays no Estado-->
                <section>
                    <h2>Inserindo em uma Posi√ß√£o Espec√≠fica</h2>
                    <p>
                      Para inserir um item em uma posi√ß√£o espec√≠fica, use a sintaxe de propaga√ß√£o junto com o m√©todo <code>slice()</code>:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                  setArtists([
                    ...artists.slice(0, insertAt),
                    { id: nextId++, name: name },
                    ...artists.slice(insertAt)
                  ]);
                  </script></code></pre>
                </section>

                <!--Slide 54 Revertendo e Ordenando Arrays-->
                <section>
                    <h2>Revertendo e Ordenando Arrays</h2>
                    <p>
                      M√©todos como <code>reverse()</code> e <code>sort()</code> mutam a array original. Para us√°-los, fa√ßa uma c√≥pia do array primeiro:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers"><script type="text/template">
                  const nextList = [...list];
                  nextList.reverse(); // ou nextList.sort();
                  setList(nextList);
                  </script></code></pre>
                </section>

                <!--Slide 55 Atualizando Objetos Dentro de Arrays-->
                <section>
                    <h2>Atualizando Objetos Dentro de Arrays</h2>
                    <p>
                      Quando o array cont√©m objetos, voc√™ deve copiar o objeto a ser modificado em vez de mut√°-lo diretamente:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim><script type="text/template">
                  setMyList(myList.map(artwork => {
                    if (artwork.id === artworkId) {
                      return { ...artwork, seen: nextSeen };
                    } else {
                      return artwork;
                    }
                  }));
                  </script></code></pre>
                </section>

                <!--Slide 56 Uso do Immer-->
                <section>
                    <h2>Uso do Immer</h2>
                    <p>
                      A biblioteca <strong>Immer</strong> permite escrever c√≥digo com muta√ß√£o direta, mas sem realmente modificar o estado original. Isso simplifica o processo de atualiza√ß√£o de arrays e objetos complexos.
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim><script type="text/template">
                  updateMyList(draft => {
                    const artwork = draft.find(a => a.id === artworkId);
                    artwork.seen = nextSeen;
                  });
                  </script></code></pre>
                </section>

                <!--Slide 57 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Reagindo √† Entrada com o Estado</h2>
                    <p>
                      O React fornece uma maneira declarativa de manipular a UI. Em vez de manipular diretamente cada elemento da interface, voc√™ descreve os diferentes estados do componente e alterna entre eles em resposta √† entrada do usu√°rio.
                    </p>
                </section>

                <!--Slide 58 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>UI Declarativa vs Imperativa</h2>
                    <p>
                      <strong>Imperativa:</strong> O programador controla diretamente o que acontece com a UI, instruindo cada mudan√ßa. √â como dar instru√ß√µes passo a passo ao motorista.
                    </p>
                    <p>
                      <strong>Declarativa:</strong> No React, voc√™ descreve o que deve ser exibido, e o React descobre como atualizar a UI. Isso torna a UI mais f√°cil de manter, especialmente em sistemas complexos.
                    </p>
                </section>

                <!--Slide 59 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Estados Visuais no React</h2>
                    <p>
                      A UI pode ter diferentes estados visuais:
                    </p>
                    <ul>
                      <li><strong>Vazio:</strong> Formul√°rio com o bot√£o "Enviar" desabilitado</li>
                      <li><strong>Digitando:</strong> O bot√£o "Enviar" √© habilitado</li>
                      <li><strong>Enviando:</strong> Formul√°rio desabilitado com um spinner</li>
                      <li><strong>Sucesso:</strong> Mensagem "Obrigado" exibida</li>
                      <li><strong>Erro:</strong> Formul√°rio com mensagem de erro</li>
                    </ul>
                </section>
                
                <!--Slide 60 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Estrutura Declarativa no React</h2>
                    <p>
                      No React, voc√™ declara o que deve ser exibido com base no estado do componente. Aqui est√° um exemplo de como declarar os diferentes estados de um formul√°rio:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim><script type="text/template">
                  export default function Form({ status = 'empty' }) {
                    if (status === 'success') return <h1>That's right!</h1>;
                    return (
                      <>
                        <form>
                          <textarea disabled={status === 'submitting'} />
                          <button disabled={status === 'empty' || status === 'submitting'}>
                            Submit
                          </button>
                          {status === 'error' && <p className="Error">Try again!</p>}
                        </form>
                      </>
                    );
                  }
                  </script></code></pre>
                </section>

                <!--Slide 61 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Entradas que Disparam Mudan√ßas de Estado</h2>
                    <p>
                      As mudan√ßas de estado podem ser acionadas por:
                    </p>
                    <ul>
                      <li><strong>Entradas humanas:</strong> Clicar em bot√µes, digitar no campo</li>
                      <li><strong>Entradas do sistema:</strong> Respostas de rede ou outros eventos ass√≠ncronos</li>
                    </ul>
                </section>

                <!--Slide 62 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Representando o Estado com useState</h2>
                    <p>
                      Use <code>useState</code> para armazenar o estado necess√°rio. Por exemplo:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                  const [answer, setAnswer] = useState('');
                  const [error, setError] = useState(null);
                  // 'typing', 'submitting', or 'success'
                  const [status, setStatus] = useState('typing');
                  </script></code></pre>
                    <p>Isso simplifica a l√≥gica e mant√©m o estado controlado.</p>
                </section>

                <!--Slide 63 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Conectando os Manipuladores de Eventos</h2>
                    <p>
                      Para reagir √†s entradas do usu√°rio, voc√™ precisar√° conectar os manipuladores de eventos. Aqui est√° um exemplo:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim><script type="text/template">
                  async function handleSubmit(e) {
                    e.preventDefault();
                    setStatus('submitting');
                    try {
                      await submitForm(answer);
                      setStatus('success');
                    } catch (err) {
                      setStatus('typing');
                      setError(err);
                    }
                  }
                  </script></code></pre>
                </section>

                <!--Slide 64 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Exemplo Completo de Formul√°rio em React</h2>
                    <p>
                      Este √© o exemplo completo do formul√°rio em React com todos os estados e l√≥gica de intera√ß√£o conectados:
                    </p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers><script type="text/template">
                  import { useState } from 'react';
                  
                  export default function Form() {
                    const [answer, setAnswer] = useState('');
                    const [error, setError] = useState(null);
                    const [status, setStatus] = useState('typing');
                  
                    if (status === 'success') return <h1>That's right!</h1>;
                  
                    async function handleSubmit(e) {
                      e.preventDefault();
                      setStatus('submitting');
                      try {
                        await submitForm(answer);
                        setStatus('success');
                      } catch (err) {
                        setStatus('typing');
                        setError(err);
                      }
                    }
                  
                    return (
                      <form onSubmit={handleSubmit}>
                        <textarea
                          value={answer}
                          onChange={e => setAnswer(e.target.value)}
                          disabled={status === 'submitting'}
                        />
                        <button disabled={answer.length === 0 || status === 'submitting'}>
                          Submit
                        </button>
                        {error && <p className="Error">{error.message}</p>}
                      </form>
                    );
                  }
                  
                  function submitForm(answer) {
                    return new Promise((resolve, reject) => {
                      setTimeout(() => {
                        if (answer.toLowerCase() === 'lima') {
                          resolve();
                        } else {
                          reject(new Error('Try again!'));
                        }
                      }, 1500);
                    });
                  }
                  </script></code></pre>
                </section>

                <!--Slide 65 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Escolhendo a Estrutura do Estado</h2>
                    <p>
                      Uma boa estrutura de estado pode facilitar a modifica√ß√£o e depura√ß√£o de componentes. Existem alguns princ√≠pios que voc√™ pode seguir para estruturar melhor o estado.
                    </p>
                </section>

                <!--Slide 66 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Princ√≠pios para Estrutura√ß√£o do Estado</h2>
                    <ul>
                      <li><strong>Grupo de estado relacionado:</strong> Vari√°veis de estado que sempre mudam juntas podem ser agrupadas.</li>
                      <li><strong>Evitar contradi√ß√µes:</strong> O estado n√£o deve ser contradit√≥rio.</li>
                      <li><strong>Evitar estado redundante:</strong> N√£o mantenha dados que podem ser derivados de props ou outras vari√°veis de estado.</li>
                    </ul>
                </section>

                  <!--Slide 66 Reagindo √† Entrada com o Estado-->
                  <section>
                    <h2>Princ√≠pios para Estrutura√ß√£o do Estado</h2>
                    <ul>
                      <li><strong>Evitar duplica√ß√£o:</strong> Dados duplicados s√£o dif√≠ceis de manter sincronizados.</li>
                      <li><strong>Evitar estados profundamente aninhados:</strong> Eles s√£o dif√≠ceis de atualizar.</li>
                    </ul>
                </section>

                <!--Slide 67 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Agrupando Estados Relacionados</h2>
                    <p>Quando duas vari√°veis de estado mudam juntas, √© prefer√≠vel agrup√°-las. Por exemplo, ao mover um cursor:</p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                  const [position, setPosition] = useState({ x: 0, y: 0 });
                  function handleMove(e) {
                    setPosition({ x: e.clientX, y: e.clientY });
                  }
                  </script></code></pre>
                </section>

                <!--Slide 68 Reagindo √† Entrada com o Estado-->
                <section>
                    <h2>Evitar Contradi√ß√µes no Estado</h2>
                    <p>Exemplo de c√≥digo onde o estado pode entrar em contradi√ß√£o:</p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim><script type="text/template">
                  const [isSending, setIsSending] = useState(false);
                  const [isSent, setIsSent] = useState(false);
                  </script></code></pre>
                    <p>Em vez disso, unifique o estado para evitar inconsist√™ncias:</p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                        // 'typing', 'sending', or 'sent'
                        const [status, setStatus] = useState('typing'); 
                  </script></code></pre>
                  </section>

                  <!--Slide 69 Reagindo √† Entrada com o Estado-->
                  <section>
                    <h2>Evitar Estado Redundante</h2>
                    <p>N√£o armazene no estado o que pode ser derivado de outras vari√°veis ou props:</p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                  const fullName = firstName + ' ' + lastName;
                  </script></code></pre>
                    <p>A vari√°vel <code>fullName</code> √© derivada e n√£o precisa ser armazenada no estado.</p>
                  </section>

                    <!--Slide 70 Reagindo √† Entrada com o Estado-->
                  <section>
                    <h2>Evitar Duplica√ß√£o no Estado</h2>
                    <p>Exemplo de c√≥digo com duplica√ß√£o de estado:</p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                  const [items, setItems] = useState(initialItems);
                  const [selectedItem, setSelectedItem] = useState(items[0]);
                  </script></code></pre>
                    <p>Em vez de duplicar, armazene apenas o <code>id</code> do item selecionado:</p>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim ><script type="text/template">
                  const [selectedId, setSelectedId] = useState(0);
                  const selectedItem = items.find(item => item.id === selectedId);
                  </script></code></pre>
                  </section>
             
        </div>
    </div>



    <script src="../../../reveal.js-master/dist/reveal.js"></script>
    <script src="../../../reveal.js-master/plugin/zoom/zoom.js"></script>
    <script src="../../../reveal.js-master/plugin/zoom/zoom.js"></script>
    <script src="../../../reveal.js-master/plugin/notes/notes.js"></script>
    <script src="../../../reveal.js-master/plugin/search/search.js"></script>
    <script src="../../../reveal.js-master/plugin/markdown/markdown.js"></script>
    <script src="../../../reveal.js-master/plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({
            controls: true,
            progress: true,
            center: true,
            hash: true,
            slideNumber: true ,
            plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
        });
    </script>
</body>